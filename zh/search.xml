<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>浅谈递归</title>
    <url>/zh/posts/About-Recursion/</url>
    <content><![CDATA[<p>递归是指在编程中函数在函数体中调用自身的过程，体现的是分而治之的思想。</p>
<p>用一张图来说明：</p>
<img data-src="/zh/posts/About-Recursion/Recursion-Google.png" class="" title="不过这个递归好像会导致栈区溢出 😂">
<span id="more"></span>
<h2 id="从与循环的关系看递归"><a class="header-anchor" href="#从与循环的关系看递归">¶</a> 从与循环的关系看递归</h2>
<p>从这个角度看，递归可以分为两种。</p>
<ol>
<li><strong>可以直接改写成循环的</strong>，这里称为第一类递归。</li>
<li><strong>改写成循环的时候需要用到栈的</strong>，这里称为第二类递归。</li>
</ol>
<p>第一种情况的例子有用于求最大公约数的辗转相除算法，还有求斐波那契数列第 n 项的算法，二分查找等：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 递归式辗转相除算法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Recursion</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> either, <span class="type">int</span> other)</span> {</span><br><span class="line">        <span class="keyword">if</span> (other == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> either;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> gcd(other, either % other)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环式辗转相除算法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Iteration</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> either, <span class="type">int</span> other)</span> {</span><br><span class="line">        <span class="keyword">while</span> (other != <span class="number">0</span>) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">remainder</span> <span class="operator">=</span> either % other;</span><br><span class="line">            either = other;</span><br><span class="line">            other = remainder;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> either;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归式斐波那契算法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Recursion</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fibonacci</span><span class="params">(<span class="type">int</span> number)</span> {</span><br><span class="line">        <span class="keyword">if</span> (number &lt; <span class="number">2</span>) {</span><br><span class="line">            <span class="keyword">return</span> number;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> fibonacci(number - <span class="number">1</span>) + fibonacci(number - <span class="number">2</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尾递归式斐波那契算法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TailRecursion</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fibonacci</span><span class="params">(<span class="type">int</span> number)</span> {</span><br><span class="line">        <span class="keyword">return</span> fibonacci(<span class="number">0</span>, <span class="number">1</span>, number);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fibonacci</span><span class="params">(<span class="type">int</span> current, <span class="type">int</span> next, <span class="type">int</span> number)</span> {</span><br><span class="line">        <span class="keyword">if</span> (number &lt; <span class="number">1</span>) {</span><br><span class="line">            <span class="keyword">return</span> current;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (number &lt; <span class="number">2</span>) {</span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> fibonacci(next, current + next, number--);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环式斐波那契算法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Iteration</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fibonacci</span><span class="params">(<span class="type">int</span> number)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; number; i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">temporary</span> <span class="operator">=</span> current + next;</span><br><span class="line">            current = next;</span><br><span class="line">            next = temporary;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> current;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>通过上面的代码可以看到，这一类的递归和循环之间存在着比较直接的对应关系，改写成循环不需要借助任何辅助数据结构，并且改写成循环之后还有可能降低开销甚至时间复杂度。例如：求斐波那契数列第 n 项的算法的递归形式的时间复杂的是惊人的 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="5.765ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2548.3 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msup" transform="translate(1152,0)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mi" transform="translate(533,363) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g><g data-mml-node="mo" transform="translate(2159.3,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>，尾递归形式的时间复杂度是 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2141 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1752,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>，而对应的循环形式的时间复杂度也是 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2141 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1752,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>。</p>
<p>第二种情况的例子有二叉树的遍历等：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 这里以二叉树的中序遍历为例</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉树节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;Item&gt; {</span><br><span class="line"></span><br><span class="line">    Item item;</span><br><span class="line">    Node&lt;Item&gt; left;</span><br><span class="line">    Node&lt;Item&gt; right;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归式二叉树中序遍历</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Recursion</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(Node&lt;Item&gt; root)</span> {</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        traverse(root.left);</span><br><span class="line">        System.out.println(root.item);</span><br><span class="line">        traverse(root.right);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环式二叉树中序遍历</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Iteration</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(Node&lt;Item&gt; root)</span> {</span><br><span class="line">        Stack&lt;Node&lt;Item&gt;&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">        Node&lt;Item&gt; node = root;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span> || !stack.isEmpty()) {</span><br><span class="line">            <span class="keyword">while</span> (node != <span class="literal">null</span>) {</span><br><span class="line">                stack.push(node);</span><br><span class="line">                node = node.left();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            node = stack.pop();</span><br><span class="line">            System.out.println(node.item);</span><br><span class="line">            node = node.right();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>通过上面的代码可以看到，这一类递归若要改写成循环需要借助栈的帮助，就此例而言时间复杂度没有变化，都为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2141 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1752,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>。</p>
<h2 id="如何区分这两种递归"><a class="header-anchor" href="#如何区分这两种递归">¶</a> 如何区分这两种递归</h2>
<h3 id="尾递归"><a class="header-anchor" href="#尾递归">¶</a> 尾递归</h3>
<p>在具体讨论如何区分这两种递归之前，我们先来了解一个已有的定义：<em>尾递归</em></p>
<p>在具体讨论尾递归之前，我们先来了解一下另一个已有的定义：<em>尾调用</em></p>
<p>尾调用是指：一个函数里的最后一个动作是返回一个函数调用的情形。例如：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">g</span><span class="params">()</span> {</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数 f 中最后一个动作是返回对函数 g 的调用，这就称之为尾调用</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">()</span> {</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> g();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数 h 最后一个动作不是返回对函数 g 的调用，而是返回对函数 g 的调用结果再加 1，这就不是尾调用了</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">h</span><span class="params">()</span> {</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> g() + <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数 i 可以改写成函数 f，但函数 i 不能算是严格意义上的尾调用</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">i</span><span class="params">()</span> {</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">int</span> g = g();</span><br><span class="line">    <span class="keyword">return</span> g;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>而尾递归就是尾调用的的特例，尾递归函数中最后一个动作是返回对该函数自身的调用。上文中，辗转相除算法的递归形式就是尾递归的例子。而尾递归属于第一类递归，即可以直接改写为循环，不需要栈的辅助。而很多现代的编译期甚至会直接对尾递归进行优化，消除调用过程中的栈帧，这样就再也不会 StackOverflow 啦。</p>
<h3 id="递归函数的执行过程"><a class="header-anchor" href="#递归函数的执行过程">¶</a> 递归函数的执行过程</h3>
<p>为了了解为什么递归会分成这两种以及为什么尾递归属于第一类递归，我们先来分析递归函数的执行过程。</p>
<p>对于任何递归函数，其执行流程都可以看成两部分：</p>
<ul>
<li>
<p>向下调用</p>
<p>向下调用是指：函数调用自身这个过程。如果把递归函数的执行过程看成一颗以初始调用为根的树，向下调用会向下加大树的深度，也就是会增加栈帧。</p>
</li>
<li>
<p>向上返回</p>
<p>向上返回是指：函数调用执行完毕，结束自身并向调用方放回的过程。如果把递归函数的执行过程看成一颗以初始调用为根的树，向上返回会向上减小树的深度，也就是会减少栈帧。</p>
</li>
</ul>
<p>以辗转相除算法的递归函数为例，其执行过程如下图所示：</p>
<img data-src="/zh/posts/About-Recursion/Recursion-Process.svg" class="" title="辗转相除算法的递归函数执行流程图示">
<p>再以二叉树的中序遍历递归函数为例，其递归调用过程如下：</p>
<img data-src="/zh/posts/About-Recursion/Inorder-Traverse.svg" class="" title="二叉树的中序遍历递归函数执行流程图示">
<h3 id="观察"><a class="header-anchor" href="#观察">¶</a> 观察</h3>
<p>首先，我们来看辗转相除算法的递归调用过程，可以发现其具备以下特征：</p>
<ol>
<li>递归调用过程单调，这里的单调是指该函数的执行过程是先连续的向下调用，紧接着连续的向上返回直至结束。</li>
<li>只在向下调用的过程中用到参数。</li>
</ol>
<p>然后，我们来看二叉树的中序遍历的递归调用过程：</p>
<ol>
<li>递归调用过程不单调，向下调用和向上返回交叉着进行。</li>
<li>在向下调用的过程中用到参数后并返回后，继续使用到了参数。</li>
</ol>
<p>基于以上观察，我们了解到区分递归函数的关键可能与以下因素有关。</p>
<ol>
<li>向上返回过程中是否用到参数。</li>
<li>递归调用过程是否单调。</li>
</ol>
<h3 id="思考"><a class="header-anchor" href="#思考">¶</a> 思考</h3>
<h4 id="递归调用过程不单调"><a class="header-anchor" href="#递归调用过程不单调">¶</a> 递归调用过程不单调</h4>
<p>我们先来思考最显而易见的情形，当递归函数的调用过程不单调时，就如上文中提到的二叉树的中序遍历，由于每一层的递归调用的参数都有可能在接下来的调用过程中被再次用到，所以必须要把每一层的调用信息（包括参数，局部变量等）都存入栈中，以备在后面的调用过程中再次使用，所以，当递归调用过程不单调的时候，栈是必须的，因此该类递归属于第二类递归，即在改写为循环时需要使用到栈。</p>
<h4 id="递归调用过程单调"><a class="header-anchor" href="#递归调用过程单调">¶</a> 递归调用过程单调</h4>
<p>既然递归调用过程不单调属于第二类递归，那么是不是递归调用过程单调就属于第一类递归了呢？答案比想象中的要复杂，请看下面的分析：</p>
<h5 id="尾递归-2"><a class="header-anchor" href="#尾递归-2">¶</a> 尾递归</h5>
<p>首先我们来看递归调用过程单调中最简单的情形 —— 尾递归：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 递归式辗转相除算法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Recursion</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> either, <span class="type">int</span> other)</span> {</span><br><span class="line">        <span class="keyword">if</span> (other == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> either;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> gcd(other, either % other)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环式辗转相除算法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Iteration</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> either, <span class="type">int</span> other)</span> {</span><br><span class="line">        <span class="keyword">while</span> (other != <span class="number">0</span>) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">remainder</span> <span class="operator">=</span> either % other;</span><br><span class="line">            either = other;</span><br><span class="line">            other = remainder;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> either;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>我们可以看到，尾递归函数的调用过程不仅单调，而且在连续向上返回的过程中除了向上层传递结果并没有额外操作，所有运算在连续向下调用的过程中就已完成，基于这种特点，我们可以认为其和循环直接等价。所以尾递归属于第一类循环，即改写为循环时无需使用栈。</p>
<h5 id="用到常数"><a class="header-anchor" href="#用到常数">¶</a> 用到常数</h5>
<p>现在我们在尾递归的基础上增加一些操作，在不改变其调用过程的单调性的前提下，在连续向上返回的这个过程中加入额外的运算：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 下面的代码仅用于说明概念，其作用已经不再是辗转相除法求最大公约数</span></span><br><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Recursion</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">final</span> <span class="variable">CONSTANT</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> either, <span class="type">int</span> other)</span> {</span><br><span class="line">        <span class="keyword">if</span> (other == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> either;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> gcd(other, either % other) + CONSTANT;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Iteration</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">final</span> <span class="variable">CONSTANT</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> either, <span class="type">int</span> other)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (other != <span class="number">0</span>) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">remainder</span> <span class="operator">=</span> either % other;</span><br><span class="line">            either = other;</span><br><span class="line">            other = remainder;</span><br><span class="line"></span><br><span class="line">            sum += CONSTANT;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> either + sum;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>我们可以看到，虽然现在的递归函数已经不像尾递归那么 “纯正”，但其仍然属于第一类递归。看来在向上返回的过程中加上和常数的操作并不能改变其性质。</p>
<h5 id="用到参数"><a class="header-anchor" href="#用到参数">¶</a> 用到参数</h5>
<p>既然加上和常数操作不能改变其性质，那么要是加上和变量的操作呢？递归函数里面的变量从哪里来呢？参数！嗯，所以我们现在来试试在不改变其调用过程的单调性的前提下，在向上返回的过程中加上对参数的操作：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 下面的代码仅用于说明概念，其作用已经不再是辗转相除法求最大公约数</span></span><br><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Recursion</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> either, <span class="type">int</span> other)</span> {</span><br><span class="line">        <span class="keyword">if</span> (other == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> either;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> gcd(other, either % other) + other;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Iteration</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> either, <span class="type">int</span> other)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (other != <span class="number">0</span>) {</span><br><span class="line">            sum += other;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">remainder</span> <span class="operator">=</span> either % other;</span><br><span class="line">            either = other;</span><br><span class="line">            other = remainder;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> either + sum;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>什么？？？怎么还是可以在改写为循环的时候不用到栈？难道递归调用过程单调就能断定递归函数属于第一类递归吗？其实不然，请看下面的例子：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 先序遍历二叉树最作边的路径上的全部节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉树节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;Item&gt; {</span><br><span class="line"></span><br><span class="line">    Item item;</span><br><span class="line">    Node&lt;Item&gt; left;</span><br><span class="line">    Node&lt;Item&gt; right;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归式二叉树先序遍历最左路径</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Recursion</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(Node&lt;Item&gt; root)</span> {</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        System.out.println(root.item);</span><br><span class="line">        traverse(root.left);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环式二叉树中先序遍历最左路径</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Iteration</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(Node&lt;Item&gt; root)</span> {</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">null</span>) {</span><br><span class="line">            System.out.println(root.item);</span><br><span class="line">            root = root.left;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归式二叉树后序遍历最左路径</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Recursion</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(Node&lt;Item&gt; root)</span> {</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        traverse(root.left);</span><br><span class="line">        System.out.println(root.item);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环式二叉树中后序遍历最左路径</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Iteration</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(Node&lt;Item&gt; root)</span> {</span><br><span class="line">        Stack&lt;Node&lt;Item&gt;&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;Item&gt; node = root; node != <span class="literal">null</span>; node = node.left) {</span><br><span class="line">            stack.push(node);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) {</span><br><span class="line">            Node&lt;Item&gt; node = stack.pop();</span><br><span class="line">            System.out.println(node);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>我们可以看到，在这个例子中，递归函数的调用过程仍然单调，同样也实在连续向上返回的过程中用到了参数，但为什么这个例子中就要用到栈呢？仔细观察，我们可以发现，上一个例子中我们作的操作比较特殊，这个操作是对一个整数的加法，而对整数的加法是一个累计的操作，我们只关心这个累计而来的结果，而不关心他是从第一个累加到最后一个还是从最后一个累加到第一个，所以在改写为循环时，通过把这些本该在第一次循环完之后再做的累加操作直接放在第一次循环中执行，就可以在不影响结果的情况下消除栈的使用。而在这个例子中，对二叉树节点的遍历操作，遍历的顺序也是影响结果的因素之一，所以对于后序遍历，我们必需要用到栈。</p>
<p>说到这里，我们再来回顾一下刚才用到常数的例子，无论是对于常数的累加操作，还是遍历操作，顺序都不会对结果造成任何影响，所以我们可以在改写为循环是消除掉对栈的使用。</p>
<h3 id="结论"><a class="header-anchor" href="#结论">¶</a> 结论</h3>
<ul>
<li>
<p>递归调用过程不单调 -&gt; 改写为循环时需要用到栈（第二类递归）</p>
</li>
<li>
<p>递归调用过程单调</p>
<ul>
<li>
<p>向上返回过程中没有用到参数 -&gt; 改写为循环时不需要用到栈（第一类递归）</p>
</li>
<li>
<p>向上返回过程中用到了参数</p>
<ul>
<li>递归调用过程中参数的使用顺序对结果无影响 -&gt; 改写为循环时不需要用到栈（第一类递归）</li>
<li>递归调用过程中参数的使用顺序对结果有影响 -&gt; 改成为循环时需要用到栈（第二类递归）</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>由于作者水平所限，并不能从数学的角度严格证明上面的结论。因此上面的结论只是基于作者自己的观察作出的总结，因此可能不够完备，甚至错误。</p>
<p>本文的目的在于尝试提供一种相对简单的判别方法用于在将一个递归函数真正改写为循环之前判断其需不需要栈的辅助。</p>
<p>如果你发现了文章中的问题，或者有更好的思路，记得在下方评论哦。😊</p>
</blockquote>
]]></content>
      <categories>
        <category>编程</category>
        <category>递归</category>
      </categories>
      <tags>
        <tag>思考</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>你好，世界</title>
    <url>/zh/posts/Hello-World/</url>
    <content><![CDATA[<p>这是我的个人博客。</p>
<p>主要分享对于技术学习和思考，但不局限于此。</p>
<p>坚持原创，不定时更新。</p>
<span id="more"></span>
<h2 id="代码"><a class="header-anchor" href="#代码">¶</a> 代码</h2>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Java</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HelloWorld</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// C</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello World!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="公式"><a class="header-anchor" href="#公式">¶</a> 公式</h2>
<p><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="8.699ex" height="2.185ex" role="img" focusable="false" viewBox="0 -883.9 3845.1 965.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D438" d="M492 213Q472 213 472 226Q472 230 477 250T482 285Q482 316 461 323T364 330H312Q311 328 277 192T243 52Q243 48 254 48T334 46Q428 46 458 48T518 61Q567 77 599 117T670 248Q680 270 683 272Q690 274 698 274Q718 274 718 261Q613 7 608 2Q605 0 322 0H133Q31 0 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H757Q764 676 764 669Q764 664 751 557T737 447Q735 440 717 440H705Q698 445 698 453L701 476Q704 500 704 528Q704 558 697 578T678 609T643 625T596 632T532 634H485Q397 633 392 631Q388 629 386 622Q385 619 355 499T324 377Q347 376 372 376H398Q464 376 489 391T534 472Q538 488 540 490T557 493Q562 493 565 493T570 492T572 491T574 487T577 483L544 351Q511 218 508 216Q505 213 492 213Z"></path></g><g data-mml-node="mo" transform="translate(1041.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(2097.6,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="msup" transform="translate(2975.6,0)"><g data-mml-node="mi"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></g><g data-mml-node="mn" transform="translate(466,413) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g></g></g></svg></mjx-container></p>
<h2 id="图表"><a class="header-anchor" href="#图表">¶</a> 图表</h2>
<pre><code class="highlight mermaid">graph TD;
    A--&gt;B;
    A--&gt;C;
    B--&gt;D;
    C--&gt;D;</code></pre>
<h2 id="图片"><a class="header-anchor" href="#图片">¶</a> 图片</h2>
<img data-src="/zh/posts/Hello-World/San-Francisco.png" class="" title="San Francisco">
<h2 id="笔记"><a class="header-anchor" href="#笔记">¶</a> 笔记</h2>
<div class="note default"><p>Hello World!</p>
</div>
<div class="note primary"><p>Hello World!</p>
</div>
<div class="note success"><p>Hello World!</p>
</div>
<div class="note info"><p>Hello World!</p>
</div>
<div class="note warning"><p>Hello World!</p>
</div>
<div class="note danger"><p>Hello World!</p>
</div>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>Paxos Made Simple 翻译及总结</title>
    <url>/zh/posts/Paxos-Made-Simple-Reading/</url>
    <content><![CDATA[<h2 id="Warm-up-预热"><a class="header-anchor" href="#Warm-up-预热">¶</a>Warm-up / 预热</h2>
<blockquote>
<p>The Paxos algorithm, when presented in plain English, is very simple.</p>
<p><strong>Leslie Lamport</strong> — Paxos Made Simple</p>
</blockquote>
<blockquote>
<p>The Fast Paxos algorithm, when presented in plain English, is still quite hard to understand for those like us — people who don’t have the brain of Leslie Lamport.</p>
<p><strong>Keith Marzullo, Alessandro Mei, and Hein Meling</strong> — A Simpler Proof for Paxos and Fast Paxos</p>
</blockquote>
<p>😂</p>
<span id="more"></span>
<h2 id="The-Problem-问题"><a class="header-anchor" href="#The-Problem-问题">¶</a>The Problem / 问题</h2>
<ul>
<li>
<p>Safety requirements for consensus / 一致性算法的基本要求:</p>
<ul>
<li><strong>1 / 约束 1: Only a value that has been proposed may be chosen / 只能通过已经被提出的值</strong></li>
<li><strong> 2 / 约束 2: Only a single value is chosen / 只能通过单个值</strong></li>
<li><strong> 3 / 约束 3: A process never learns that a value has been chosen unless it actually has been / 只能了解已经被通过的值</strong></li>
</ul>
</li>
<li>
<p>Roles / 角色</p>
<ul>
<li>
<p>Proposers / 议长，发起议案</p>
</li>
<li>
<p>Acceptors / 议员，赞成议案</p>
</li>
<li>
<p>Learners / 听众，了解议案</p>
</li>
</ul>
<blockquote>
<p>A single process may act as more than one agent / 允许身兼数职</p>
</blockquote>
</li>
<li>
<p>Asynchronous, non-Byzantine model / 异步，非拜占庭模型:</p>
<ul>
<li>Asynchronous / 异步: Agents operate at arbitrary speed, may fail by stopping, and may restart. Since all agents may fail after a value is chosen and then restart, a solution is impossible unless some information can be remembered by an agent that has failed and restarted. / 代理以任意速度运行，可能失效，也可能重启。由于可能出现在通过一个值以后全部代理都失效，所以代理失效前需要保存一些必要的信息，否则将无法恢复。</li>
<li>Non-Byzantine / 非拜占庭: Messages can take arbitrarily long to be delivered, can be duplicated, and can be lost, but they are not corrupted. / 消息可能耗费任意长的时间送达，可能重复，也可能丢失，但是不会出错（保证发送的消息和接收到的消息一致）。</li>
</ul>
</li>
</ul>
<h2 id="Choosing-a-Value-值的通过"><a class="header-anchor" href="#Choosing-a-Value-值的通过">¶</a>Choosing a Value / 值的通过</h2>
<h3 id="Single-acceptor-agent-单个议员"><a class="header-anchor" href="#Single-acceptor-agent-单个议员">¶</a>Single acceptor agent / 单个议员</h3>
<p>A proposer sends a proposal to the acceptor, who chooses the first proposed value that it receives. / 议长向议员发送一份议案，议员通过最开始接收到的议案。</p>
<blockquote>
<p>Simple but unsatisfactory, because the failure of the acceptor makes any further progress impossible. / 简单但是还不够好，因为议员一旦失效，整个系统也随之失效。</p>
</blockquote>
<h3 id="Multiple-acceptor-agents-多个议员"><a class="header-anchor" href="#Multiple-acceptor-agents-多个议员">¶</a>Multiple acceptor agents / 多个议员</h3>
<p>A proposer sends a proposed value to a set of acceptors. An acceptor may accept the proposed value. The value is chosen when a large enough set of acceptors have accepted it. How large is large enough? To ensure that only a single value is chosen, we can let a large enough set consist of any majority of the agents. Because any two majorities have at least one acceptor in common, this works if an acceptor can accept at most one value. / 一个议长将一份议案发送给一组议员。一个议员可能赞成该议案，也可能不赞成。当足够多的议员赞成了该议案，那么该议案就将通过。具体要多少议员赞成才是足够多？为了保证只有单个议案被通过，我们必须保证这一组议员包含全体议员中的多数议员 *，因为任何两组多数议员至少会包含一位共有议员，如果一位议员只能赞成一个提案的话，那么就能保证只有单个议案被通过。</p>
<blockquote>
<p>*Majority / * 多数: Majority means that a set is consisted of more than half of all acceptors / 多数表示这一组议员由全体议员的<strong>一半以上</strong>的议员组成。</p>
</blockquote>
<p>In the absence of failure or message loss, we want a value to be chosen even if only one value is proposed by a single proposer. / 在没有失效和信息丢失的情况下，如果只有一位议长，并且只提了一份议案，那么这个议案就应该被通过（否则系统将不能正常运行下去）。</p>
<ul>
<li><strong>P1 / 约束 P1: An acceptor must accept the first proposal that it receives. / 一位议员必须赞成其收到的第一份议案。</strong></li>
</ul>
<p>But this requirement raises a problem. Several values could be proposed by different proposers at about the same time, leading to a situation in which every acceptor has accepted a value, but no single value is accepted by a majority of them. Even with just two proposed values, if each is accepted by about half the acceptors, failure of a single acceptor could make it impossible to learn which of the values was chosen. / 但是约束 P1 还不够完备。不同的议长可能会同时发起多个不同的议案，可能导致不同的议员赞成了不同的议案，但是没有议案获得了多数议员的赞成。<strong>假设有两个议案，每个都获得了大约半数议员的赞同，如果议员总数为偶数个，系统将直接陷入死锁；如果议员总数为奇数个，那么最终决定权就落在了单个议员的手里，如果这时候该议员失效，那么系统就将陷入死锁。</strong></p>
<blockquote>
<p>上面的翻译我综合了自己的理解，可能和原文有些对应不上。</p>
</blockquote>
<p>P1 and the requirement that a value is chosen only when it is accepted by a majority of acceptors imply that an acceptor must be allowed to accept more than one proposal. / 约束 P1 和约束<em>当一份议案被多数议员赞成后才会被通过</em>隐含了条件<em>一位议员必须可以赞成不止一份议案</em>。（反证法）</p>
<p>We keep track of the different proposals that an acceptor may accept by assigning a (natural) number to each proposal, so a proposal consists of a proposal number and a value. To prevent confusion, we require that different proposals have different numbers. / 现在我们给议案分配一个自然数，所以现在一份议案是一个二元组（议案序号，值）。同时，为了唯一确定每一份议案，我们规定每一份议案的序号确定且唯一，并且议案的序号必须满足全序关系（全序关系即集合<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="1.928ex" height="1.545ex" role="img" focusable="false" viewBox="0 -683 852 683"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44B" d="M42 0H40Q26 0 26 11Q26 15 29 27Q33 41 36 43T55 46Q141 49 190 98Q200 108 306 224T411 342Q302 620 297 625Q288 636 234 637H206Q200 643 200 645T202 664Q206 677 212 683H226Q260 681 347 681Q380 681 408 681T453 682T473 682Q490 682 490 671Q490 670 488 658Q484 643 481 640T465 637Q434 634 411 620L488 426L541 485Q646 598 646 610Q646 628 622 635Q617 635 609 637Q594 637 594 648Q594 650 596 664Q600 677 606 683H618Q619 683 643 683T697 681T738 680Q828 680 837 683H845Q852 676 852 672Q850 647 840 637H824Q790 636 763 628T722 611T698 593L687 584Q687 585 592 480L505 384Q505 383 536 304T601 142T638 56Q648 47 699 46Q734 46 734 37Q734 35 732 23Q728 7 725 4T711 1Q708 1 678 1T589 2Q528 2 496 2T461 1Q444 1 444 10Q444 11 446 25Q448 35 450 39T455 44T464 46T480 47T506 54Q523 62 523 64Q522 64 476 181L429 299Q241 95 236 84Q232 76 232 72Q232 53 261 47Q262 47 267 47T273 46Q276 46 277 46T280 45T283 42T284 35Q284 26 282 19Q279 6 276 4T261 1Q258 1 243 1T201 2T142 2Q64 2 42 0Z"></path></g></g></g></svg></mjx-container>上的反对称（若 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.312ex;" xmlns="http://www.w3.org/2000/svg" width="5.185ex" height="1.882ex" role="img" focusable="false" viewBox="0 -694 2291.6 832"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mo" transform="translate(806.8,0)"><path data-c="2264" d="M674 636Q682 636 688 630T694 615T687 601Q686 600 417 472L151 346L399 228Q687 92 691 87Q694 81 694 76Q694 58 676 56H670L382 192Q92 329 90 331Q83 336 83 348Q84 359 96 365Q104 369 382 500T665 634Q669 636 674 636ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"></path></g><g data-mml-node="mi" transform="translate(1862.6,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g></g></g></svg></mjx-container> 且 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.312ex;" xmlns="http://www.w3.org/2000/svg" width="5.185ex" height="1.882ex" role="img" focusable="false" viewBox="0 -694 2291.6 832"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mo" transform="translate(706.8,0)"><path data-c="2264" d="M674 636Q682 636 688 630T694 615T687 601Q686 600 417 472L151 346L399 228Q687 92 691 87Q694 81 694 76Q694 58 676 56H670L382 192Q92 329 90 331Q83 336 83 348Q84 359 96 365Q104 369 382 500T665 634Q669 636 674 636ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"></path></g><g data-mml-node="mi" transform="translate(1762.6,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g></g></g></svg></mjx-container> 则 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="5.185ex" height="1.756ex" role="img" focusable="false" viewBox="0 -694 2291.6 776"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mo" transform="translate(806.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(1862.6,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g></g></g></svg></mjx-container>）的、传递（若 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.312ex;" xmlns="http://www.w3.org/2000/svg" width="5.185ex" height="1.882ex" role="img" focusable="false" viewBox="0 -694 2291.6 832"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mo" transform="translate(806.8,0)"><path data-c="2264" d="M674 636Q682 636 688 630T694 615T687 601Q686 600 417 472L151 346L399 228Q687 92 691 87Q694 81 694 76Q694 58 676 56H670L382 192Q92 329 90 331Q83 336 83 348Q84 359 96 365Q104 369 382 500T665 634Q669 636 674 636ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"></path></g><g data-mml-node="mi" transform="translate(1862.6,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g></g></g></svg></mjx-container> 且 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.312ex;" xmlns="http://www.w3.org/2000/svg" width="4.967ex" height="1.882ex" role="img" focusable="false" viewBox="0 -694 2195.6 832"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mo" transform="translate(706.8,0)"><path data-c="2264" d="M674 636Q682 636 688 630T694 615T687 601Q686 600 417 472L151 346L399 228Q687 92 691 87Q694 81 694 76Q694 58 676 56H670L382 192Q92 329 90 331Q83 336 83 348Q84 359 96 365Q104 369 382 500T665 634Q669 636 674 636ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"></path></g><g data-mml-node="mi" transform="translate(1762.6,0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></g></g></g></svg></mjx-container> 则 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.312ex;" xmlns="http://www.w3.org/2000/svg" width="5.194ex" height="1.751ex" role="img" focusable="false" viewBox="0 -636 2295.6 774"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mo" transform="translate(806.8,0)"><path data-c="2264" d="M674 636Q682 636 688 630T694 615T687 601Q686 600 417 472L151 346L399 228Q687 92 691 87Q694 81 694 76Q694 58 676 56H670L382 192Q92 329 90 331Q83 336 83 348Q84 359 96 365Q104 369 382 500T665 634Q669 636 674 636ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"></path></g><g data-mml-node="mi" transform="translate(1862.6,0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></g></g></g></svg></mjx-container>）的和完全（<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.312ex;" xmlns="http://www.w3.org/2000/svg" width="5.185ex" height="1.882ex" role="img" focusable="false" viewBox="0 -694 2291.6 832"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mo" transform="translate(806.8,0)"><path data-c="2264" d="M674 636Q682 636 688 630T694 615T687 601Q686 600 417 472L151 346L399 228Q687 92 691 87Q694 81 694 76Q694 58 676 56H670L382 192Q92 329 90 331Q83 336 83 348Q84 359 96 365Q104 369 382 500T665 634Q669 636 674 636ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"></path></g><g data-mml-node="mi" transform="translate(1862.6,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g></g></g></svg></mjx-container> 或 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.312ex;" xmlns="http://www.w3.org/2000/svg" width="5.185ex" height="1.882ex" role="img" focusable="false" viewBox="0 -694 2291.6 832"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mo" transform="translate(706.8,0)"><path data-c="2264" d="M674 636Q682 636 688 630T694 615T687 601Q686 600 417 472L151 346L399 228Q687 92 691 87Q694 81 694 76Q694 58 676 56H670L382 192Q92 329 90 331Q83 336 83 348Q84 359 96 365Q104 369 382 500T665 634Q669 636 674 636ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"></path></g><g data-mml-node="mi" transform="translate(1762.6,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g></g></g></svg></mjx-container>）的二元关系，简而言之，集合内的任意两个元素可以比较大小，计算机中的整型就满足全序关系，而 IEEE 754 定义的浮点数中，由于 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.686ex;" xmlns="http://www.w3.org/2000/svg" width="13.447ex" height="2.498ex" role="img" focusable="false" viewBox="0 -801 5943.6 1104"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g><g data-mml-node="mi" transform="translate(888,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(1417,0)"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g><g data-mml-node="mo" transform="translate(2582.8,0)"><path data-c="2270" d="M82 -124Q82 -120 83 -117T89 -110T95 -103H220L284 50Q346 204 344 206L218 268Q153 297 123 313T87 333T82 344T86 355Q104 369 291 455Q491 552 491 553L542 673Q581 767 590 784T609 801Q616 801 622 795T629 781Q629 773 586 677Q546 581 546 577L609 606Q669 635 673 635Q680 635 686 629T693 615Q693 610 692 608T670 593T604 561L524 521L400 226L542 157Q617 123 649 107T687 85T694 72Q694 66 690 60T679 54Q664 54 526 121Q513 127 495 136T464 150T438 162T416 173T399 180T388 185L384 186Q383 186 322 41L262 -103H680Q682 -105 684 -108T688 -113T691 -118T693 -124Q693 -134 682 -141L464 -143H246L213 -219Q182 -292 178 -299Q172 -303 166 -303T153 -297T146 -283Q146 -282 174 -213T202 -143H146L93 -141Q82 -134 82 -124ZM418 370L466 495Q464 495 308 420T151 344T204 317T311 267T364 244Q364 247 418 370Z"></path></g><g data-mml-node="mi" transform="translate(3638.6,0)"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g><g data-mml-node="mi" transform="translate(4526.6,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(5055.6,0)"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g></g></g></svg></mjx-container>，所以 IEEE 754 不满足全序关系）。</p>
<p>A value is chosen when a single proposal with that value has been accepted by a majority of the acceptors. In that case, we say that the proposal (as well as its value) has been chosen. / 当一份包含值 v 的议案被多数议员赞成的时候，我们就说该议案（也包括值 v） 被通过了。</p>
<p>We can allow multiple proposals to be chosen, but we must guarantee that all chosen proposals have the same value. / 现在我们可以通过多个议案了，但是我们必须确保通过的多个议案都包含相同的值，这样才能保证约束 2。</p>
<ul>
<li>P2 / 约束 P2: If a proposal with value v is chosen, then <strong>every higher-numbered</strong> proposal that is chosen has value v. / 如果一份包含值 v 的议案已被通过，那么<strong>每一份大序号更大的</strong>议案都应该包含值 v。</li>
</ul>
<p>Since numbers are totally ordered, condition P2 guarantees the crucial safety property that only a single value is chosen. / 由于议案序号满足全序关系，所以约束 P2 能保证约束 2。</p>
<p>To be chosen, a proposal must be accepted by at least one acceptor. / 一份议案要被通过，那么这份议案至少要被一位议员赞成。</p>
<p>So, we can satisfy P2 by satisfying / 所以，我们可以对约束 P2 进行加强：</p>
<ul>
<li>P2a / 约束 P2a: If a proposal with value v is chosen, then every higher-numbered proposal accepted by any acceptor has value v. / 如果一份包含值 v 的议案已被通过，那么每一份被任何议员赞成的序号更大的议案也包含值 v。</li>
</ul>
<p>We still maintain P1 to ensure that some proposal is chosen. / 此时，我们仍然需要保证约束 P1，以确保有议案被通过。</p>
<p>Because communication is asynchronous, a proposal could be chosen with some particular acceptor c never having received any proposal. Suppose a new proposer “wakes up” and issues a higher-numbered proposal with a different value. P1 requires c to accept this proposal, violating P2a. / 但是由于通讯是异步的，可能出现某些特定的议员，比如议员 c 完全没有参与某个议案的情况。然后，议长又发起了一份更大序号的并且包含不同的值的议案，这时，根据约束 P1 议员 c 应该赞成该议案，但是这种情况却违反了约束 P2a。</p>
<p>Maintaining both P1 and P2a requires strengthening P2a to / 所以我们在约束 P2a 的基础上继续增强约束:</p>
<ul>
<li>P2b / 约束 P2b: If a proposal with value v is chosen, then every higher-numbered proposal issued by any proposer has value v. / 如果一份包含值 v 的议案已被通过，那么每一份被议长发起的序号更大的议案都包含值 v。</li>
</ul>
<p>Since a proposal must be issued by a proposer before it can be accepted by an acceptor, P2b implies P2a, which in turn implies P2. / 由于一份议案在被议员赞成之前必须现有议案则发起，所以约束 P2b 蕴含约束 P2a，又因为约束 P2a 蕴含约束 P2，故约束 P2b 也蕴含约束 P2。</p>
<p>To discover how to satisfy P2b, let’s consider how we would prove that it holds. / 约束 P2b 虽然约束足够强，但是难以提出实现方式，所以我们通过证明约束 P2b 成立的方式来进一步加强约束。</p>
<p>We would assume that some proposal with number m and value v is chosen and show that any proposal issued with number n &gt; m also has value v. / 假设一份序号为 m 值为 v 的议案 (m, v) 已经被通过，试证任何已发起的序号为 n 且 n &gt; m 的议案都包含值 v。</p>
<p>We would make the proof easier by using induction on n, so we can prove that proposal number n has value v under the additional assumption that every proposal issued with a number in m . . (n − 1) has value v , where i . . j denotes the set of numbers from i through j . / 为了简化证明过程，我们对 n 使用数学归纳法，这样我们就可以通过附加假设条件每一份以及发起的序号在 m 到 n-1 这个闭区间的议案都包含值 v 来证明序号为 n 的议案包含值 v。</p>
<p>For the proposal numbered m to be chosen, there must be some set C consisting of a majority of acceptors such that every acceptor in C accepted it. / 对于将要被通过的序号为 m 的议案，一定存在一个集合 C 由多数议员构成，并且集合 C 中的所有议员都赞成了该议案。</p>
<p>Combining this with the induction assumption, the hypothesis that m is chosen implies / 再结合刚才的归纳假设，假设 m 已被通过则意味着:</p>
<center>
    Every acceptor in C has accepted a proposal with number in m ..(n − 1), and every proposal with number in m ..(n − 1) accepted by any acceptor has value v. / 集合 C 中的每一位议员都接受了序号在 m 到 n-1 这个闭区间中的某个提议，并且每个序号在 m 到 n-1 这个闭区间中的提议都被包含值 v 的任意一位议员接受了。
</center>
<p>Since any set S consisting of a majority of acceptors contains at least one member of C, we can conclude that a proposal numbered n has value v by ensuring that the following invariant is maintained / 回顾前面对于‘多数’议员的定义，由于任意由多数议员组成的集合 S 和集合 C 之间至少有一位共同议员，那么我们通过保证以下的不变性来得出序号为 n 的议案包含值 v 的结论:</p>
<ul>
<li>P2c / 约束 P2c: For any v and n, if a proposal with value v and number n is issued, then there is a set S consisting of a majority of acceptors such that either (a) no acceptor in S has accepted any proposal numbered less than n, or (b) v is the value of the highest-numbered proposal among all proposals numbered less than n accepted by the acceptors in S. / 对于任意的 v 和 n，如果一份值为 v 序号为 n 的议案被发起，那么就存在一个由多数议员构成的集合 S 满足下列条件之一：(a) 集合 S 中没有任何一个议员赞成了任何序号小于 n 的议案；(b) v 是集合 S 中的议员所赞成的所有序号小于 n 的议案中序号最大的那一份议案所包含的值。</li>
</ul>
<blockquote>
<p>结合 P2c 的假设和条件 (b) 可以证明 P2c 蕴含了 P2b</p>
</blockquote>
<p>To maintain the invariance of P2c, a proposer that wants to issue a proposal numbered n must learn the highest-numbered proposal with number less than n, if any, that has been or will be accepted by each acceptor in some majority of acceptors. / 为了维持约束 P2c 的不变性，当一位议长想发起一份值为 n 的议案之前，如果存在序号小于 n 的的议案的话，他必须先知道其中已经或者将要被多数议员赞成的序号最大的那一份议案。</p>
<p>Learning about proposals already accepted is easy enough; predicting future acceptances is hard. Instead of trying to predict the future, the proposer controls it by extracting a promise that there won’t be any such acceptances. In other words, the proposer requests that the acceptors not accept any more proposals numbered less than n. / 相对于预测将来的议员赞成情况而言，了解已经被议员赞成的议案要简单得多。因此，与其花大力气去预测未来，还不如通过承诺的方式来让议长控制不会有不符合条件的议案赞成情况。换句话说，议长要求议员作出承诺，保证不会再赞成序号小于 n 的议案。</p>
<p>This leads to the following algorithm for issuing proposals. / 这样，我们就得到了发起议案的算法:</p>
<ol>
<li>
<p>A proposer chooses a new proposal number n and sends a request to each member of some set of acceptors, asking it to respond with / 一位议长通过一个新的议案序号 n，然后向某个集合（应该是‘多数’议员）的全部议员发起请求，并要求对方回复以下两方面的内容:</p>
<p>(a) A promise never again to accept a proposal numbered less than n, and / 要求对方作出承诺，保证不再赞成任何序号小于 n 的议案</p>
<p>(b) The proposal with the highest number less than n that it has accepted, if any. / 已经赞成的序号小于 n 的议案中，序号最大的那一份议案</p>
<p>I will call such a request a prepare request with number n.  / 我们将这个过程称作序号 n 的准备请求</p>
</li>
<li>
<p>If the proposer receives the requested responses from a majority of the acceptors, then it can issue a proposal with number n and value v, where v is the value of the highest-numbered proposal among the responses, or is any value selected by the proposer if the responders reported no proposals. / 如果议长收到了多数议员的回复，那么他才能够发起序号为 n 值为 v 的议案，其中 v 是收到的回复中的所有议案里序号最大的那一份议案的值，如果所有回复中都不包含议案，那么 v 则由议长自行指定。</p>
</li>
</ol>
<p>A proposer issues a proposal by sending, to some set of acceptors, a request that the proposal be accepted. (This need not be the same set of acceptors that responded to the initial requests.), Let’s call this an accept request. / 最后，议长将确定好的议案作为请求发送给一组议员（<strong>这里的这一组议员不能和初始阶段的一样</strong>），我们将这个过程称为赞成请求。</p>
<p>What about an acceptor? It can receive two kinds of requests from proposers: prepare requests and accept
requests. An acceptor can ignore any request without compromising safety. / 对于议员而言，其可以接收两种来自议长的请求：准备请求和赞成请求。并且议员会忽略掉那些不满足约束的请求。</p>
<p>So, we need to say only when it is allowed to respond to a request. It can always respond to a prepare request. It can respond to an accept request, accepting the proposal, iff it has not promised not to. In other words / 所以，对于准备请求而言，议员总是可以响应；对于赞成请求而言，当且仅当该议员没有承诺过不赞成该请求时，才响应。换句话说 :</p>
<ul>
<li>P1a / 约束 P1a: An acceptor can accept a proposal numbered n iff it has not responded
to a prepare request having a number greater than n. / 当且仅当一位议员没有响应过序号大于 n 的准备请求时，该议员才能赞成序号为 n 的议案。</li>
</ul>
<p>Observe that P1a subsumes P1. / 通过观察可以发现约束 P1a 蕴含 P1。</p>
<p>We now have a complete algorithm for choosing a value that satisfies the required safety properties—assuming unique proposal numbers. The final algorithm is obtained by making one small optimization. / 至此，在议案序号唯一的前提下，我们通过推导得到了完整的通过值的算法。最终的算法还可以在此基础上做一些优化。</p>
<p>Suppose an acceptor receives a prepare request numbered n, but it has already responded to a prepare request numbered greater than n, thereby promising not to accept any new proposal numbered n. There is then no reason for the acceptor to respond to the new prepare request, since it will not accept the proposal numbered n that the proposer wants to issue. So we have the acceptor ignore such a prepare request. We also have it ignore a prepare request for a proposal it has already accepted. 在议员已经响应了一个序号大于 n 的准备请求以后，对于序号为 n 的准备请求就没有必要响应了。同时，对于已经赞成的议案，也没有必要再赞成第二次。</p>
<p>With this optimization, an acceptor needs to remember only the highest-numbered proposal that it has ever accepted and the number of the highest-numbered prepare request to which it has responded. Because P2c must be kept invariant regardless of failures, an acceptor must remember this
information even if it fails and then restarts. / 经过上面的优化以后，议员只需要保存他赞成过的议案中序号最大的那一份和响应过得准备请求中序号最大的那一个就行。因为即使在有失效的情况下我们也必须维护约束 P2c 的不变性，议员就算经历失效或者重启也必须保存上面的信息。</p>
<p>Note that the proposer can always abandon a proposal and forget all about it—as long as it never tries to issue another proposal with the same number. / 值得注意的是，议长总是可以通过不再发起相同序号的新议案的方式来放弃并且遗忘调一份议案。</p>
<h3 id="Conclude-总结"><a class="header-anchor" href="#Conclude-总结">¶</a>Conclude / 总结</h3>
<p>Requirements for the algorithm / 算法的约束:</p>
<ul>
<li>1 / 约束 1: <strong>Only a value that has been proposed may be chosen / 只能通过已经被提出的值</strong></li>
<li> 2 / 约束 2: <strong>Only a single value is chosen / 只能通过单个值</strong></li>
<li> 3 / 约束 3: <strong>A process never learns that a value has been chosen unless it actually has been / 只能了解已经被通过的值</strong></li>
<li> P1a / 约束 P1a: <strong>An acceptor can accept a proposal numbered n iff it has not responded to a prepare request having a number greater than n. / 当且仅当一位议员没有响应过序号大于 n 的准备请求时，该议员才能赞成序号为 n 的议案。</strong></li>
<li>P2c / 约束 P2c: <strong>For any v and n, if a proposal with value v and number n is issued, then there is a set S consisting of a majority of acceptors such that either (a) no acceptor in S has accepted any proposal numbered less than n, or (b) v is the value of the highest-numbered proposal among all proposals numbered less than n accepted by the acceptors in S. / 对于任意的 v 和 n，如果一份值为 v 序号为 n 的议案被发起，那么就存在一个由多数议员构成的集合 S 满足下列条件之一：(a) 集合 S 中没有任何一个议员赞成了任何序号小于 n 的议案；(b) v 是集合 S 中的议员所赞成的所有序号小于 n 的议案中序号最大的那一份议案所包含的值。</strong></li>
</ul>
<p>Properties of the algorithm / 算法的特性:</p>
<ul>
<li>
<p>Immutability of value / 值的不可变性</p>
<blockquote>
<p>要么集群中没有任何议案被提出，这时没有值，一旦有合法的议案被提出，无论后面有多少新的合法的议案被提出，值都是最开始的合法议案中的值。所以称值具有不可变性。</p>
</blockquote>
</li>
<li>
<p>Minority obeying majority / 少数服从多数</p>
<blockquote>
<p>多数定义是至少为全体的一半以上（不包括刚好一半）。</p>
</blockquote>
</li>
<li>
<p>Prevent the occurrence, Instead of trying to predict the future / 与其预测未来，不如提前预防</p>
<blockquote>
<p>要求议员在准备阶段作出承诺。</p>
</blockquote>
</li>
</ul>
<h3 id="The-Algorithm-算法"><a class="header-anchor" href="#The-Algorithm-算法">¶</a>The Algorithm / 算法</h3>
<p>Putting the actions of the proposer and acceptor together, we see that the algorithm operates in the following two phases. / 将上面的过程整合在一起，我们就得到了最终的算法（通过值部分）:</p>
<ul>
<li>
<p>Phase 1 / 阶段 1</p>
<ul>
<li>(a) A proposer selects a proposal number n and sends a prepare request with number n to a majority of acceptors. / 一位议长通过一份议案序号 n，并向多数议员发送序号为 n 的准备请求。</li>
<li>(b) If an acceptor receives a prepare request with number n greater than that of any prepare request to which it has already responded, then it responds to the request with a promise not to accept any more proposals numbered less than n and with the highest-numbered proposal (if any) that it has accepted. / 如果一位议员接收到的序号为 n 的准备请求的序号大于了任何已经响应的准备请求，那么该议员将响应接收到的序号为 n 的准备请求，作出承诺不再赞成任何序号小于 n 的，并且，如果已经赞成过任何议案的话，顺便返回其中序号最大的那一个（同发起议案算法第 1 点）。</li>
</ul>
</li>
<li>
<p>Phase 2 / 阶段 2</p>
<ul>
<li>(a) If the proposer receives a response to its prepare requests (numbered n) from a majority of acceptors, then it sends an accept request to each of those acceptors for a proposal numbered n with a value v, where v is the value of the highest-numbered proposal among the responses, or is any value if the responses reported no proposals. / 如果议长收到了多数议员对序号为 n 的准备请求的响应，那么议长就开始向另一组多数议员中的每一位发送序号为 n 值为 v 的议案，其中 v 是收到的响应中的议案中序号最大的那一份议案所包含的值，如果收到的响应中不包含任何议案，那么值 v 由议长任意指定。</li>
<li>(b) If an acceptor receives an accept request for a proposal numbered n, it accepts the proposal unless it has already responded to a prepare request having a number greater than n. / 如果一位议员收到序号为 n 的赞成请求，在没有响应过序号大于 n 的准备请求的情况下，该议员将赞成此议案。</li>
</ul>
</li>
</ul>
<p>A proposer can make multiple proposals, so long as it follows the algorithm for each one. / 议长可以发起多个议案，前提是每一份议案都需要按照算法的流程进行。</p>
<p>It can abandon a proposal in the middle of the protocol at any time. (Correctness is maintained, even though requests and/or responses for the proposal may arrive at their destinations long after the proposal was abandoned.) / 议长可以在任何时候中途废弃议案。（尽管请求或者响应可能在到达目的地之前就已经被废弃，但正确性依然不会受到影响。）</p>
<p>It is probably a good idea to abandon a proposal if some proposer has begun trying to issue a higher-numbered one. / 在某个议长尝试发起一个序号更大的议案时，废弃已有的议案可能是个不错的想法。</p>
<p>Therefore, if an acceptor ignores a prepare or accept request because it has already received a prepare request with a higher number, then it should probably inform the proposer, who should then abandon its proposal. This is a performance optimization that does not affect correctness. / 因此，在一位议员因为已经接收到了更大序号的准备请求后，而忽略当前准备或者赞成请求的时候，该议员应该通知相应的议长废弃当前议案。这在不影响正确性的情况下提高了性能。</p>
<h2 id="Learning-a-Chosen-Value-了解已通过的值"><a class="header-anchor" href="#Learning-a-Chosen-Value-了解已通过的值">¶</a>Learning a Chosen Value / 了解已通过的值</h2>
<p>To learn that a value has been chosen, a learner must find out that a proposal has been accepted by a majority of acceptors. The obvious algorithm is to have each acceptor, whenever it accepts a proposal, respond to all learners, sending them the proposal. This allows learners to find out about a chosen value as soon as possible, but it requires each acceptor to respond to each learner—a number of responses equal to the product of the number of acceptors and the number of learners. / 为了使听众了解已经被通过的值，听众必须得知道被多数议员赞成的议案的内容。最直观的算法就是，每当议员赞成某个提案时，就通知所有的听众，向他们发送该议案。这样可以保证及时性，但是复杂度太高，达到了 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="8.967ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 3963.4 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1974.2,0)"><path data-c="2217" d="M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z"></path></g><g data-mml-node="mi" transform="translate(2696.4,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(3574.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container> ，这里 n 是议员个数，m 是听众个数。</p>
<p>The assumption of non-Byzantine failures makes it easy for one learner to find out from another learner that a value has been accepted. We can have the acceptors respond with their acceptances to a distinguished learner, which in turn informs the other learners when a value has been chosen. This approach requires an extra round for all the learners to discover the chosen value. It is also less reliable, since the distinguished learner could fail. But it requires a number of responses equal only to the sum of the number of acceptors and the number of learners. / 回顾前面的非拜占庭假设，我们发现听众可以通过其他听众来准确的了解已被赞成的议案。这样一来，议员就只需要通知某个特定的听众了，剩下的通知工作就可以由听众之间的相互传递来完成。于是，复杂度降低到了 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="9.596ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 4241.4 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1974.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(2974.4,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(3852.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container> 。但是，这样的话这位特定的听众就成了单点，会导致可靠性下降很多。</p>
<blockquote>
<p>复杂度好像还可以更低，如果听众之间用 P2P 通信，应该可以降到 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="13.434ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 5938 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1974.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(2974.4,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="mi" transform="translate(3272.4,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"></path></g><g data-mml-node="msub" transform="translate(3757.4,0)"><g data-mml-node="mi"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"></path></g><g data-mml-node="mn" transform="translate(510,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mi" transform="translate(4671,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(5549,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></p>
</blockquote>
<p>More generally, the acceptors could respond with their acceptances to some set of distinguished learners, each of which can then inform all the learners when a value has been chosen. Using a larger set of distinguished learners provides greater reliability at the cost of greater communication complexity. / 介于以上两种策略都有致命的缺陷，一种复杂度太高，另一种可靠性太低，于是我们取两者的折中方案。将第二种方法中的特定听众由一位扩展到一组。以此提高可靠性，但是会以复杂度的提升为代价，需要根据具体场景做权衡。</p>
<p>Because of message loss, a value could be chosen with no learner ever finding out. The learner could ask the acceptors what proposals they have accepted, but failure of an acceptor could make it impossible to know whether or not a majority had accepted a particular proposal. In that case, learners will find out what value is chosen only when a new proposal is chosen. If a learner needs to know whether a value has been chosen, it can have a proposer issue a proposal, using the algorithm described above. / 由于消息有可能会丢失，那么就可能出现一个值被通过了，却没有任何听众了解。听众可以主动询问议员已经赞成了什么议案，但是在极端情况（多数议员之间只有一个共同议员的情况）下，一位议员失效就将导致无法区分该议案是否获得了多数议员的赞成。在这种情况下，听众只能被动的在新的提案被通过的时候才能了解被多数议员赞成的值。如果听众需要主动获得当先被多数议员通过的值，那么他只能通过发起一次新的议案来达到目的，但这也要求该听众同时也是议长（身兼多职）。</p>
<h2 id="The-Progress-过程"><a class="header-anchor" href="#The-Progress-过程">¶</a>The Progress / 过程</h2>
<p>It’s easy to construct a scenario in which two proposers each keep issuing a sequence of proposals with increasing numbers, none of which are ever chosen. Proposer p completes phase 1 for a proposal number n1. Another proposer q then completes phase 1 for a proposal number n2 &gt; n1. Proposer p’s phase 2 accept requests for a proposal numbered n1 are ignored because the acceptors have all promised not to accept any new proposal numbered less than n2. So, proposer p then begins and completes phase 1 for a new proposal number n3 &gt; n2, causing the second phase 2 accept requests of proposer q to be ignored. And so on. / 即使对于上面的算法，仍然可以轻易的构造出两位议长交替发起序号更大的议案，但却无法最终确定的情况，称之为活锁。例如：议长 p 完成了序号为 n1 的阶段 1。另一位议长 q 然后完成了序号 n2 的阶段 1，并且 n2 &gt; n1。议长 p 的阶段 2 的赞成请求会由于议员响应了 议长 q 的 n2 的准备请求（保证不再赞成任何序号小于 n2 的议案）而被忽略。这样，议长 p 就会发起序号为 n3 的阶段 1，且 n3 &gt; n2，于是议长 q 的 序号为 n2 的议案的阶段 2 又会由于议员响应了 议长 p 的 n3 的准备请求（保证不再赞成任何序号小于 n3 的议案）而被忽略，以此循环往复，无休无止。</p>
<p>To guarantee progress, a distinguished proposer must be selected as the only one to try issuing proposals. If the distinguished proposer can communicate successfully with a majority of acceptors, and if it uses a proposal with number greater than any already used, then it will succeed in issuing a proposal that is accepted. By abandoning a proposal and trying again if it learns about some request with a higher proposal number, the distinguished proposer will eventually choose a high enough proposal number.  / 为了保证流程的正常进行，避免活锁的情况，系统中必须只能有一位议长，并且作为唯一的议案发起者，当该议长能够正常的和多数议员通信并且使用大于任何已有议案的序号的议案序号，那么就能保证发起的议案被正常赞成。当该议长了解更大的序号时，废弃当前议案，并发起一份序号更大的议案，以此往复，最终就能发起一份序号足够大的议案，并获得赞成。</p>
<blockquote>
<p>这样一来，这位集群中唯一的议长就成了单点，为了解决这个问题，需要一种选举算法，在这位议长失效或重启时，及时的选举出替代者，以保证集群正常运作。</p>
</blockquote>
<blockquote>
<p>值得注意的是，为了避免活锁，算法现在只允许集群中有一位议长，而不是最开始的多位议长了，并且增加了议长选举机制（可能是从议员或者听众之间选举，也可能是其他角色）。</p>
</blockquote>
<p>If enough of the system (proposer, acceptors, and communication network) is working properly, liveness can therefore be achieved by electing a single distinguished proposer. / 如果有足够多的系统（单个议长，多位议员，以及通信网络）正常运行，集群的健康度就能通过议长的选举来保证。</p>
<h2 id="Extension-拓展"><a class="header-anchor" href="#Extension-拓展">¶</a>Extension / 拓展</h2>
<ul>
<li>
<p>The Part-Time Parliament</p>
<p>Paxos 算法的最初论文。</p>
<blockquote>
<p>论文：The Part-Time Parliament, by Leslie Lamport</p>
</blockquote>
</li>
<li>
<p>Multi-Paxos</p>
<p>Paxos 是对一个值达成一致，Multi-Paxos 是运行多个 Paxos 实例来对多个值达成一致，每个 Paxos 实例对不同的值达成一致。</p>
<blockquote>
<p>论文：Multi-Paxos: An Implementation and Evaluation, by Hao Du and David J. St. Hilaire</p>
</blockquote>
</li>
<li>
<p>Fast-Paxos</p>
<p>Paxos 的进一步工程化，就是 Client 的提案由 Coordinator 进行，Coordinator 存在多个，但只能通过其中被选定 Leader 进行；提案由 Leader 交由 Server (Acceptor) 进行表决，之后 Client 作为 Learner 学习决议的结果。这种方式更多地考虑了 Client / Server 这种通用架构，更清楚地注意到了 Client 既作为 Proposer 又作为 Learner 这一事实。</p>
<blockquote>
<p>论文：Fast Paxos, by Leslie Lamport</p>
<p>论文：A Simpler Proof for Paxos and Fast Paxos, by by Keith Marzullo, Alessandro Mei and Hein Meling</p>
</blockquote>
</li>
<li>
<p>Raft</p>
<p>Raft is a consensus algorithm that is designed to be easy to understand. It’s equivalent to Paxos in fault-tolerance and performance. The difference is that it’s decomposed into relatively independent subproblems, and it cleanly addresses all major pieces needed for practical systems. / Raft 算法被设计的更容易理解。在容错和性能方面与 Paxos 算法相当。</p>
<blockquote>
<p>论文及实现：<a href="https://raft.github.io/">Raft Consensus Algorithm</a></p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>分布式系统</category>
      </categories>
      <tags>
        <tag>论文翻译</tag>
      </tags>
  </entry>
  <entry>
    <title>关于</title>
    <url>/zh/about/index.html</url>
    <content><![CDATA[<center>热爱计算机</center>
<center>热爱互联网</center>
<center>热爱人工智能</center>
<br>
<center>极客</center>
<center>完美主义者</center>
<center>兴趣和好奇心驱动</center>
<br>
<center>保持初心，特立独行。</center>
]]></content>
  </entry>
  <entry>
    <title>书籍</title>
    <url>/zh/books/index.html</url>
    <content><![CDATA[<h2 id="程序设计语言"><a class="header-anchor" href="#程序设计语言">¶</a> 程序设计语言</h2>
<h3 id="基础"><a class="header-anchor" href="#基础">¶</a> 基础</h3>
<ul>
<li>
<p>《C 程序设计语言》（The C Programming Language）</p>
<p>作者：Brian Kernighan，Dennis Ritchie</p>
</li>
<li>
<p>《C++ Primer》</p>
<p>作者：Stanley B. Lippman，Josée Lajoie，Barbara E. Moo</p>
</li>
<li>
<p>《Java 编程思想》（Thinking in Java）</p>
<p>作者：Bruce Eckel</p>
</li>
</ul>
<h3 id="进阶"><a class="header-anchor" href="#进阶">¶</a> 进阶</h3>
<ul>
<li>
<p>《Java 并发编程实战》（Java Concurrency in Practice）</p>
<p>作者：Brian Goetz，Tim Peierls，Joshua Bloch，Joseph Bowbeer，David Holmes，Doug Lea</p>
</li>
<li>
<p>《深入理解 Java 虚拟机：JVM 高级特性与最佳实践》</p>
<p>作者：周志明</p>
</li>
</ul>
<h2 id="算法与数据结构"><a class="header-anchor" href="#算法与数据结构">¶</a> 算法与数据结构</h2>
<h3 id="基础-2"><a class="header-anchor" href="#基础-2">¶</a> 基础</h3>
<ul>
<li>
<p>《算法》（Algorithms）</p>
<p>作者：Robert Sedgewick，Kevin Wayne</p>
</li>
<li>
<p>《算法导论》（Introduction to Algorithms）</p>
<p>作者：Thomas H. Cormen，Charles E. Leiserson，Ronald L. Rivest，Clifford Stein</p>
</li>
</ul>
<h3 id="进阶-2"><a class="header-anchor" href="#进阶-2">¶</a> 进阶</h3>
<ul>
<li>
<p>《算法分析导论》（An Introduction to the Analysis of Algorithms）</p>
<p>作者：Robert Sedgewick, Philippe Flajolet</p>
</li>
</ul>
<h2 id="数据库"><a class="header-anchor" href="#数据库">¶</a> 数据库</h2>
<h3 id="基础-3"><a class="header-anchor" href="#基础-3">¶</a> 基础</h3>
<ul>
<li>
<p>《数据库系统：全书》（Database Systems: The Complete Book）</p>
<p>作者：Hector Garcia-Molina，Jeff Ullman，Jennifer Widom</p>
</li>
</ul>
<h3 id="进阶-3"><a class="header-anchor" href="#进阶-3">¶</a> 进阶</h3>
<ul>
<li>
<p>《高性能 MySQL》（High Performance MySQL: Optimization, Backups, and Replication）</p>
<p>作者：Baron Schwartz，Peter Zaitsev，Vadim Tkachenko</p>
</li>
<li>
<p>《MySQL 技术内幕：InnoDB 存储引擎》</p>
<p>作者：姜承尧</p>
</li>
<li>
<p>《Redis 设计与实现》</p>
<p>作者：黄健宏</p>
</li>
</ul>
<h2 id="计算机网络"><a class="header-anchor" href="#计算机网络">¶</a> 计算机网络</h2>
<h3 id="基础-4"><a class="header-anchor" href="#基础-4">¶</a> 基础</h3>
<ul>
<li>
<p>《计算机网络：自顶向下方法》（Computer Networking: A Top-Down Approach）</p>
<p>作者：James F. Kurose，Keith W. Ross</p>
</li>
</ul>
<h3 id="进阶-4"><a class="header-anchor" href="#进阶-4">¶</a> 进阶</h3>
<ul>
<li>
<p>《TCP/IP 详解 卷 1：协议》（TCP/IP Illustrated, Volume 1: The Protocols）</p>
<p>作者：W. Richard Stevens</p>
</li>
<li>
<p>《TCP/IP 详解 卷 2：实现》（TCP/IP Illustrated, Volume 2: The Implementation）</p>
<p>作者：W. Richard Stevens</p>
</li>
<li>
<p>《TCP/IP 详解 卷 3：TCP 事务协议、HTTP、NNTP 和 UNIX 域协议》（TCP/IP Illustrated, Vol. 3: TCP for Transactions, HTTP, NNTP, and the UNIX Domain Protocols）</p>
<p>作者：W. Richard Stevens</p>
</li>
<li>
<p>《UNIX 网络编程 卷 1：套接字联网 API》（Unix Network Programming, Volume 1: The Sockets Networking API）</p>
<p>作者：W. Richard Stevens，Bill Fenner，Andrew M. Rudof</p>
</li>
<li>
<p>《UNIX 网络编程 卷 2：进程间通信》（UNIX Network Programming, Volume 2: Interprocess Communications）</p>
<p>作者：W. Richard Stevens</p>
</li>
</ul>
<h2 id="操作系统"><a class="header-anchor" href="#操作系统">¶</a> 操作系统</h2>
<h3 id="基础-5"><a class="header-anchor" href="#基础-5">¶</a> 基础</h3>
<ul>
<li>
<p>《现代操作系统》（Modern Operating Systems）</p>
<p>作者：Andrew S. Tanenbaum</p>
</li>
</ul>
<h3 id="进阶-5"><a class="header-anchor" href="#进阶-5">¶</a> 进阶</h3>
<ul>
<li>
<p>《UNIX 环境高级编程》（Advanced Programming in the UNIX Environment）</p>
<p>作者：W. Richard Stevens，Stephen A. Rago</p>
</li>
</ul>
<h2 id="计算机体系结构"><a class="header-anchor" href="#计算机体系结构">¶</a> 计算机体系结构</h2>
<h3 id="基础-6"><a class="header-anchor" href="#基础-6">¶</a> 基础</h3>
<ul>
<li>
<p>《计算机体系结构：量化研究方法》（Computer Architecture: A Quantitative Approach）</p>
<p>作者：John L. Hennessy，David A. Patterson</p>
</li>
<li>
<p>《计算机组成与设计：硬件、软件接口》（Computer Organization and Design: The Hardware/Software Interface）</p>
<p>作者：David A. Patterson，John L. Hennessy</p>
</li>
</ul>
<h2 id="编译原理"><a class="header-anchor" href="#编译原理">¶</a> 编译原理</h2>
<h3 id="基础-7"><a class="header-anchor" href="#基础-7">¶</a> 基础</h3>
<ul>
<li>
<p>《编译原理》（Compilers: Principles, Techniques, and Tools）</p>
<p>作者：Alfred V. Aho，Monica S. Lam，Ravi Sethi，Jeffrey D. Ullman</p>
</li>
</ul>
<h2 id="计算机科学"><a class="header-anchor" href="#计算机科学">¶</a> 计算机科学</h2>
<h3 id="基础-8"><a class="header-anchor" href="#基础-8">¶</a> 基础</h3>
<ul>
<li>
<p>《深入理解计算机系统》（Computer Systems: A Programmer’s Perspective）</p>
<p>作者：Randal E. Bryant，David R. O’Hallaron</p>
</li>
</ul>
<h2 id="机器学习"><a class="header-anchor" href="#机器学习">¶</a> 机器学习</h2>
<h3 id="基础-9"><a class="header-anchor" href="#基础-9">¶</a> 基础</h3>
<ul>
<li>
<p>《机器学习》</p>
<p>作者：周志华</p>
</li>
<li>
<p>《统计学习方法》</p>
<p>作者：李航</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>分类</title>
    <url>/zh/categories/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>课程</title>
    <url>/zh/courses/index.html</url>
    <content><![CDATA[<h2 id="算法与数据结构"><a class="header-anchor" href="#算法与数据结构">¶</a> 算法与数据结构</h2>
<h3 id="基础"><a class="header-anchor" href="#基础">¶</a> 基础</h3>
<ul>
<li>
<p>Algorithms, <a href="https://www.coursera.org/learn/algorithms-part1">Part I</a>, <a href="https://www.coursera.org/learn/algorithms-part2">Part II</a></p>
<p>导师：Robert Sedgewick、Kevin Wayne</p>
<p>机构：Princeton University</p>
<p>平台：Coursera</p>
</li>
<li>
<p><a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/">6.006: Introduction to Algorithms</a></p>
<p>导师：Erik Demaine，Srinivas Devadas</p>
<p>机构：MIT</p>
<p>平台：MIT OpenCourseWare</p>
</li>
</ul>
<h3 id="进阶"><a class="header-anchor" href="#进阶">¶</a> 进阶</h3>
<ul>
<li>
<p><a href="https://www.coursera.org/learn/analysis-of-algorithms">Analysis of Algorithms</a></p>
<p>导师：Robert Sedgewick</p>
<p>机构：Princeton University</p>
<p>平台：Coursera</p>
</li>
<li>
<p><a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-design-and-analysis-of-algorithms-spring-2015/">6.046J: Design and Analysis of Algorithms</a></p>
<p>导师：Erik Demaine、Srinivas Devadas、Nancy Lynch</p>
<p>机构：MIT</p>
<p>平台：MIT OpenCourseWare</p>
</li>
</ul>
<h2 id="数据库"><a class="header-anchor" href="#数据库">¶</a> 数据库</h2>
<h3 id="基础-2"><a class="header-anchor" href="#基础-2">¶</a> 基础</h3>
<ul>
<li>
<p><a href="https://lagunita.stanford.edu/courses/Home/Databases/Engineering/about">Databases Mini-courses, Introduction to Databases</a></p>
<p>导师：Jennifer Widom</p>
<p>机构：Stanford University</p>
<p>平台：Stanford Lagunita</p>
</li>
</ul>
<h2 id="计算机网络"><a class="header-anchor" href="#计算机网络">¶</a> 计算机网络</h2>
<h3 id="基础-3"><a class="header-anchor" href="#基础-3">¶</a> 基础</h3>
<ul>
<li>
<p><a href="https://lagunita.stanford.edu/courses/Engineering/Networking-SP/SelfPaced/about">Introduction to Computer Networking</a></p>
<p>导师：Philip Levis、Nick McKeown</p>
<p>机构：Stanford University</p>
<p>平台：Stanford Lagunita</p>
</li>
</ul>
<h2 id="操作系统"><a class="header-anchor" href="#操作系统">¶</a> 操作系统</h2>
<h3 id="进阶-2"><a class="header-anchor" href="#进阶-2">¶</a> 进阶</h3>
<ul>
<li>
<p><a href="https://pdos.csail.mit.edu/6.828/2018/">6.828: Operating System Engineering</a></p>
<p>导师：Adam Belay、Frans Kaashoek</p>
<p>机构：MIT</p>
<p>平台：MIT</p>
</li>
</ul>
<h2 id="计算机体系结构"><a class="header-anchor" href="#计算机体系结构">¶</a> 计算机体系结构</h2>
<h3 id="基础-4"><a class="header-anchor" href="#基础-4">¶</a> 基础</h3>
<ul>
<li>
<p><a href="https://www.coursera.org/learn/comparch">Computer Architecture</a></p>
<p>导师：David Wentzlaff</p>
<p>机构：Princeton University</p>
<p>平台：Coursera</p>
</li>
</ul>
<h2 id="编译原理"><a class="header-anchor" href="#编译原理">¶</a> 编译原理</h2>
<h3 id="基础-5"><a class="header-anchor" href="#基础-5">¶</a> 基础</h3>
<ul>
<li>
<p><a href="https://lagunita.stanford.edu/courses/Engineering/Compilers/Fall2014/about">Compilers</a></p>
<p>导师：Alex Aiken</p>
<p>机构：Stanford University</p>
<p>平台：Stanford Lagunita</p>
</li>
</ul>
<h2 id="数学"><a class="header-anchor" href="#数学">¶</a> 数学</h2>
<h3 id="基础-6"><a class="header-anchor" href="#基础-6">¶</a> 基础</h3>
<ul>
<li>
<p><a href="https://www.coursera.org/learn/mathematical-thinking">Introduction to Mathematical Thinking</a></p>
<p>导师：Keith Devlin</p>
<p>机构：Stanford University</p>
<p>平台：Coursera</p>
</li>
<li>
<p><a href="https://www.coursera.org/learn/logic-introduction">Introduction to Logic</a></p>
<p>导师：Michael Genesereth</p>
<p>机构：Stanford University</p>
<p>平台：Coursera</p>
</li>
</ul>
<h3 id="进阶-3"><a class="header-anchor" href="#进阶-3">¶</a> 进阶</h3>
<ul>
<li>
<p><a href="https://lagunita.stanford.edu/courses/Engineering/CVX101/Winter2014/about">Convex Optimization</a></p>
<p>导师：Stephen Boyd、Henryk Blasinski、Neal Parikh、Ernest Ryu、Madeleine Udell</p>
<p>机构：Stanford University</p>
<p>平台：Stanford Lagunita</p>
</li>
</ul>
<h2 id="分布式系统"><a class="header-anchor" href="#分布式系统">¶</a> 分布式系统</h2>
<h3 id="进阶-4"><a class="header-anchor" href="#进阶-4">¶</a> 进阶</h3>
<ul>
<li>
<p><a href="https://pdos.csail.mit.edu/6.824/">6.824: Distributed Systems</a></p>
<p>导师：Robert Morris、Malte Schwarzkopf</p>
<p>机构：MIT</p>
<p>平台：MIT</p>
</li>
</ul>
<h2 id="机器学习"><a class="header-anchor" href="#机器学习">¶</a> 机器学习</h2>
<h3 id="基础-7"><a class="header-anchor" href="#基础-7">¶</a> 基础</h3>
<ul>
<li>
<p><a href="https://www.coursera.org/learn/machine-learning">Machine Learning</a></p>
<p>导师：Andrew Ng</p>
<p>机构：Stanford University</p>
<p>平台：Coursera</p>
</li>
<li>
<p><a href="https://www.coursera.org/specializations/deep-learning">Deep Learning Specialization</a></p>
<p>导师：Andrew Ng</p>
<p>机构：<a href="http://deeplearning.ai">deeplearning.ai</a></p>
<p>平台：Coursera</p>
</li>
<li>
<p><a href="https://lagunita.stanford.edu/courses/HumanitiesSciences/StatLearning/Winter2016/about">Statistical Learning</a></p>
<p>导师：Trevor Hastie、Rob Tibshirani</p>
<p>机构：Stanford University</p>
<p>平台：Stanford Lagunita</p>
</li>
</ul>
<h3 id="进阶-5"><a class="header-anchor" href="#进阶-5">¶</a> 进阶</h3>
<ul>
<li>
<p><a href="http://cs231n.stanford.edu/2017/">CS231n: Convolutional Neural Networks for Visual Recognition</a>, <a href="https://www.youtube.com/playlist?list=PL3FW7Lu3i5JvHM8ljYj-zLfQRF3EO8sYv">课程视频</a></p>
<p>导师：Fei-Fei Li、Justin Johnson、Serena Yeung</p>
<p>机构：Stanford University</p>
<p>平台：Stanford University</p>
</li>
<li>
<p><a href="https://web.stanford.edu/class/archive/cs/cs224n/cs224n.1162/">CS224n: Natural Language Processing</a>, <a href="https://www.youtube.com/playlist?list=PL3FW7Lu3i5Jsnh1rnUwq_TcylNr7EkRe6">课程视频</a></p>
<p>导师：Chris Manning</p>
<p>机构：Stanford University</p>
<p>平台：Stanford University</p>
</li>
<li>
<p><a href="http://rail.eecs.berkeley.edu/deeprlcourse/">CS 294-112 Deep Reinforcement Learning</a></p>
<p>导师：Sergey Levine</p>
<p>机构：UC Berkeley</p>
<p>平台：UC Berkeley</p>
</li>
</ul>
<h2 id="密码学"><a class="header-anchor" href="#密码学">¶</a> 密码学</h2>
<h3 id="基础-8"><a class="header-anchor" href="#基础-8">¶</a> 基础</h3>
<ul>
<li>
<p>Cryptography, <a href="https://www.coursera.org/learn/crypto">I</a>, <a href="https://www.coursera.org/learn/crypto2">II</a></p>
<p>导师：Dan Boneh</p>
<p>机构：Stanford University</p>
<p>平台：Coursera</p>
</li>
</ul>
<h2 id="博弈论"><a class="header-anchor" href="#博弈论">¶</a> 博弈论</h2>
<h3 id="基础-9"><a class="header-anchor" href="#基础-9">¶</a> 基础</h3>
<ul>
<li>
<p>Game Theory, <a href="https://www.coursera.org/learn/game-theory-1">I</a>, <a href="https://www.coursera.org/learn/game-theory-2">II</a></p>
<p>导师：Matthew O. Jackson、Kevin Leyton-Brown、Yoav Shoham</p>
<p>机构：Stanford University、The University of British Columbia</p>
<p>平台：Coursera</p>
</li>
</ul>
<h2 id="程序设计语言"><a class="header-anchor" href="#程序设计语言">¶</a> 程序设计语言</h2>
<h3 id="基础-10"><a class="header-anchor" href="#基础-10">¶</a> 基础</h3>
<ul>
<li>
<p><a href="https://www.coursera.org/learn/unix">The Unix Workbench</a></p>
<p>导师：Sean Kross、Jeff Leek、Brian Caffo、Roger D. Peng</p>
<p>机构：Johns Hopkins University</p>
<p>平台：Coursera</p>
</li>
</ul>
<h3 id="进阶-6"><a class="header-anchor" href="#进阶-6">¶</a> 进阶</h3>
<ul>
<li>
<p>Programming Languages, <a href="https://www.coursera.org/learn/programming-languages">A</a>, <a href="https://www.coursera.org/learn/programming-languages-part-b">B</a>, <a href="https://www.coursera.org/learn/programming-languages-part-c">C</a></p>
<p>导师：Dan Grossman</p>
<p>机构：University of Washington</p>
<p>平台：Coursera</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>论文</title>
    <url>/zh/papers/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>标签</title>
    <url>/zh/tags/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
